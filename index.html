<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>改进版弹球打砖块（移动端横屏）</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #111; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: 0 auto; background: #222; }
    /* 可选：竖屏时给出轻提示（不遮挡游戏，仅在极窄竖屏时出现） */
    @media screen and (orientation:portrait) {
      body::after{
        content:"请横屏体验更佳效果";
        position:fixed; left:50%; transform:translateX(-50%);
        top:8px; color:#fff; font: 14px/1.6 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
        opacity:.75; pointer-events:none;
      }
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<!-- 音效资源 -->
<audio id="hitSound" src="https://actions.google.com/sounds/v1/impacts/wood_plank_flicks.ogg"></audio>
<audio id="buffSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
<audio id="levelUpSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
<audio id="gameOverSound" src="https://actions.google.com/sounds/v1/cartoon/woodpecker.ogg"></audio>
<!-- 仍然使用原文件中的背景音乐；如需更换马里奥风格可再告诉我替换链接 -->
<audio id="bgMusic" src="https://ia802302.us.archive.org/27/items/TetrisThemeMusic/Tetris.mp3" loop></audio>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ========= 屏幕与缩放 =========
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  // 调整挡板位置到底部，避免高度变化后挡板离开屏幕
  paddle.y = canvas.height - 20;
  // 限制挡板不出界
  if (paddle.x + paddle.w > canvas.width) paddle.x = Math.max(0, canvas.width - paddle.w);
}
window.addEventListener("resize", resizeCanvas);

// ========= 音效 =========
const hitSound = document.getElementById("hitSound");
const buffSound = document.getElementById("buffSound");
const levelUpSound = document.getElementById("levelUpSound");
const gameOverSound = document.getElementById("gameOverSound");
const bgMusic = document.getElementById("bgMusic");
bgMusic.volume = 0.3;
// 移动端音频解锁（首次交互时尝试播放）
let audioUnlocked = false;
function unlockAudio() {
  if (!audioUnlocked) {
    bgMusic.play().catch(()=>{}); // 某些浏览器仍需用户交互后才允许
    audioUnlocked = true;
  }
}
window.addEventListener("touchstart", unlockAudio, {passive:true});
window.addEventListener("mousedown", unlockAudio);

// ========= 游戏对象 =========
let paddle = { x: 0, y: 0, w: 100, h: 10, speed: 7 };
let balls = [];
let waitingLaunch = true;
let bricks = [];
let buffs = [];
let bullets = []; // 炮弹
let score = 0;
let lives = 3;
let level = 1;
let rightPressed = false, leftPressed = false;
let spaceRequested = false; // 在 update 里统一处理

// 最高分（本地存储）
let highScore = Number(localStorage.getItem("breakoutHighScore") || 0);
function updateHighScore() {
  if (score > highScore) {
    highScore = score;
    localStorage.setItem("breakoutHighScore", String(highScore));
  }
}

// buff 状态
let buffStates = {
  longPaddle: false,
  splitBall: false,
  superPenetrate: false
};

// “缓慢球”效果管理
let slowActive = false;
let slowTimerId = null;
const SLOW_FACTOR = 0.6;
function applySlowBall(durationMs = 6000) {
  if (!slowActive) {
    for (let b of balls) {
      if (b.speedScale === 1) {
        b.dx *= SLOW_FACTOR;
        b.dy *= SLOW_FACTOR;
        b.speedScale = SLOW_FACTOR;
      }
    }
    slowActive = true;
  }
  if (slowTimerId) clearTimeout(slowTimerId);
  slowTimerId = setTimeout(() => {
    for (let b of balls) {
      if (b.speedScale === SLOW_FACTOR) {
        b.dx /= SLOW_FACTOR;
        b.dy /= SLOW_FACTOR;
        b.speedScale = 1;
      }
    }
    slowActive = false;
    slowTimerId = null;
  }, durationMs);
}

// “10秒无增益→下一次碰砖必定掉落分裂球”
let lastBuffSpawnTime = performance.now();
let forceNextDropSplit = false;

// “小于等于5块时，每8s生成一次蓄力炮弹（在挡板两端）；按空格/轻点发射”
let chargeAmmo = 0;
let lastChargeTime = 0;

// ========= 砖块初始化（根据屏宽自适应列数） =========
function initBricks() {
  bricks = [];
  const rows = 3 + level;
  // 基于屏幕宽度决定列数，间距/尺寸尽量沿用原风格
  const cellSpacing = 90; // 原设计的步进
  const marginX = 60;
  let maxCols = Math.max(5, Math.floor((canvas.width - marginX*2) / cellSpacing));
  // 保留原“6~8列随机”的感觉，同时不超过 maxCols
  let baseCols = Math.min(maxCols, 6 + Math.floor(Math.random()*3)); // 6~8
  const cols = Math.max(5, baseCols);

  const brickW = 40, brickH = 40;
  const startX = Math.max(20, (canvas.width - (cols-1)*cellSpacing) / 2 - brickW/2); // 居中摆放
  const startY = 50;

  for (let r=0; r<rows; r++) {
    for (let c=0; c<cols; c++) {
      if (Math.random() < 0.8) {
        const durability = Math.ceil(Math.random()*3); // 1~3
        bricks.push({
          x: startX + c*cellSpacing + Math.random()*10,
          y: startY + r*50 + Math.random()*10,
          w: brickW, h: brickH,
          durability
        });
      }
    }
  }
}

// ========= 绘制工具 =========
function getBrickColor(d) {
  if (d===1) return "#6a8";
  if (d===2) return "#aa6";
  if (d===3) return "#864";
  return "#888";
}

function drawBall(ball) {
  ball.trail.push({x: ball.x, y: ball.y});
  if (ball.trail.length>15) ball.trail.shift();
  for (let i=0; i<ball.trail.length; i++) {
    const alpha = i/ball.trail.length;
    ctx.beginPath();
    ctx.arc(ball.trail[i].x, ball.trail[i].y, ball.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,0,0,${alpha})`;
    ctx.fill();
  }
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fillStyle = "red";
  ctx.fill();
}

function drawBricks() {
  for (let b of bricks) {
    ctx.fillStyle = getBrickColor(b.durability);
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 5;
    ctx.beginPath();
    if (ctx.roundRect) ctx.roundRect(b.x, b.y, b.w, b.h, 6);
    else ctx.rect(b.x, b.y, b.w, b.h);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawPaddle() {
  ctx.fillStyle = "#ccc";
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.w, paddle.h, 4);
  else ctx.rect(paddle.x, paddle.y, paddle.w, paddle.h);
  ctx.fill();

  // 若有蓄力炮弹，挡板两端显示能量球
  if (chargeAmmo > 0) {
    const r = 6;
    ctx.beginPath();
    ctx.arc(paddle.x, paddle.y, r, 0, Math.PI*2);
    ctx.arc(paddle.x + paddle.w, paddle.y, r, 0, Math.PI*2);
    ctx.fillStyle = "#0af";
    ctx.fill();
  }
}

// HUD 动态靠右
function drawHUD() {
  const rightX = Math.max(10, canvas.width - 180);
  ctx.fillStyle = "white";
  ctx.font = "16px Arial";
  ctx.fillText(`分数: ${score}`, 20, 20);
  ctx.fillText(`最高分: ${highScore}`, 20, 40);
  ctx.fillText(`生命: ${lives}`, 20, 60);
  ctx.fillText(`关卡: ${level}`, 20, 80);

  ctx.fillText("Buff 图例:", rightX, 20);
  drawBuffIcon(rightX, 30, "#0f0", "加长木棍");
  drawBuffIcon(rightX, 55, "#0ff", "分裂球");
  drawBuffIcon(rightX, 80, "#b3f", "缓慢球");
  drawBuffIcon(rightX, 105, "#ff0", "超级穿透");

  ctx.fillText("激活中:", rightX, 140);
  let sy = 160;
  if (paddle.w > 100) { drawBuffIcon(rightX, sy, "#0f0", "加长中"); sy+=25; }
  if (slowActive) { drawBuffIcon(rightX, sy, "#b3f", "缓慢中"); sy+=25; }
  if (buffStates.superPenetrate) { drawBuffIcon(rightX, sy, "#ff0", "超穿透"); sy+=25; }

  ctx.fillText(`炮弹: ${chargeAmmo}`, rightX, sy+20);
}

function drawBuffIcon(x, y, color, text) {
  ctx.fillStyle = color;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(x, y, 20, 20, 5);
  else ctx.rect(x, y, 20, 20);
  ctx.fill();
  ctx.fillStyle = "#fff";
  ctx.font = "12px Arial";
  ctx.fillText(text, x+25, y+15);
}

function drawBuffs() {
  for (let buff of buffs) {
    ctx.fillStyle = buff.color;
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 4;
    ctx.beginPath();
    if (ctx.roundRect) ctx.roundRect(buff.x, buff.y, buff.size, buff.size, 4);
    else ctx.rect(buff.x, buff.y, buff.size, buff.size);
    ctx.fill();
    ctx.shadowBlur=0;
  }
}

function drawBullets() {
  ctx.fillStyle = "#0af";
  for (let blt of bullets) {
    ctx.beginPath();
    ctx.arc(blt.x, blt.y, 4, 0, Math.PI*2);
    ctx.fill();
  }
}

// ========= 掉落与碰撞 =========
function spawnBuff(x, y, forcedType = null) {
  const types = ["longPaddle", "splitBall", "slowBall", "superPenetrate"];
  const type = forcedType || types[Math.floor(Math.random()*types.length)];
  const colorMap = {
    longPaddle: "#0f0",
    splitBall: "#0ff",
    slowBall: "#b3f",
    superPenetrate: "#ff0"
  };
  buffs.push({x: x-10, y: y-10, size:20, dy:2, type, color: colorMap[type]});
  lastBuffSpawnTime = performance.now();
  forceNextDropSplit = false;
}

function collisionCircleRect(ball, rect) {
  return ball.x+ball.r>rect.x && ball.x-ball.r<rect.x+rect.w &&
         ball.y+ball.r>rect.y && ball.y-ball.r<rect.y+rect.h;
}

// ========= 发射/开火 =========
function handleSpaceAction() {
  if (waitingLaunch) {
    waitingLaunch = false;
    return;
  }
  if (chargeAmmo > 0) {
    bullets.push({ x: paddle.x, y: paddle.y, dy: -12 });
    bullets.push({ x: paddle.x + paddle.w, y: paddle.y, dy: -12 });
    chargeAmmo -= 1;
  }
}

// ========= 主更新 =========
function update() {
  // 键盘移动
  if (rightPressed && paddle.x+paddle.w<canvas.width) paddle.x+=paddle.speed;
  if (leftPressed && paddle.x>0) paddle.x-=paddle.speed;

  // 轻点触发的统一处理
  if (spaceRequested) {
    handleSpaceAction();
    spaceRequested = false;
  }

  // 10秒内无增益出现 → 下一次碰砖必掉分裂球
  if (!forceNextDropSplit && performance.now() - lastBuffSpawnTime >= 10000) {
    forceNextDropSplit = true;
  }

  // 小于等于5块 → 每8s 增加1枚蓄力炮弹
  if (bricks.length <= 5 && bricks.length > 0) {
    if (performance.now() - lastChargeTime >= 8000) {
      chargeAmmo += 1;
      lastChargeTime = performance.now();
    }
  } else {
    lastChargeTime = performance.now();
  }

  // 更新球
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];

    if (waitingLaunch) {
      ball.x = paddle.x + paddle.w/2;
      ball.y = paddle.y - ball.r - 2;
      continue;
    }

    ball.x += ball.dx;
    ball.y += ball.dy;

    // 边界
    if (ball.x+ball.r>canvas.width || ball.x-ball.r<0) ball.dx*=-1;
    if (ball.y-ball.r<0) ball.dy*=-1;

    // 触底
    if (ball.y+ball.r>canvas.height) {
      balls.splice(i,1);
      if (balls.length===0) {
        lives--;
        if (lives<=0) {
          gameOverSound.play();
          updateHighScore();
          alert("游戏结束! 得分: "+score+"  最高分: "+highScore);
          document.location.reload();
          return;
        } else {
          balls=[{x:paddle.x+paddle.w/2,y:paddle.y-10,dx:4,dy:-4,r:8,trail:[], speedScale: slowActive ? SLOW_FACTOR : 1}];
          if (slowActive) { balls[0].dx *= SLOW_FACTOR; balls[0].dy *= SLOW_FACTOR; }
          waitingLaunch=true;
        }
      }
      continue;
    }

    // 挡板反弹
    if (ball.x>paddle.x && ball.x<paddle.x+paddle.w && ball.y+ball.r>paddle.y && ball.y-ball.r<paddle.y+paddle.h) {
      ball.dy*=-1;
    }

    // 砖块碰撞
    for (let j=bricks.length-1; j>=0; j--) {
      const b = bricks[j];
      if (collisionCircleRect(ball, b)) {
        try { hitSound.currentTime=0; hitSound.play(); } catch(e){}

        // 超级穿透
        if (buffStates.superPenetrate) {
          bricks.splice(j,1);
          score+=10; updateHighScore();
          if (forceNextDropSplit) {
            spawnBuff(b.x+b.w/2, b.y+b.h/2, "splitBall");
          } else if (Math.random()<0.3) {
            spawnBuff(b.x+b.w/2, b.y+b.h/2);
          }
          continue;
        }

        // 非穿透：伤害/掉落/反弹
        b.durability--;
        let destroyed = false;
        if (b.durability<=0) {
          destroyed = true;
          bricks.splice(j,1);
          score+=10; updateHighScore();
        }

        if (forceNextDropSplit) {
          spawnBuff(b.x+b.w/2, b.y+b.h/2, "splitBall");
        } else if (destroyed && Math.random()<0.3) {
          spawnBuff(b.x+b.w/2, b.y+b.h/2);
        }

        ball.dy*=-1;
      }
    }
  }

  // 更新 buff 掉落物
  for (let i=buffs.length-1; i>=0; i--) {
    let buff = buffs[i];
    buff.y += buff.dy;
    if (buff.y>canvas.height) {
      buffs.splice(i,1);
      continue;
    }
    // 吃到 buff
    if (buff.x < paddle.x + paddle.w && buff.x + buff.size > paddle.x &&
        buff.y + buff.size > paddle.y && buff.y < paddle.y + paddle.h) {
      try { buffSound.currentTime=0; buffSound.play(); } catch(e){}

      if (buff.type==="longPaddle") {
        paddle.w = 150;
        setTimeout(()=>{ paddle.w = 100; }, 10000);
      }
      if (buff.type==="splitBall") {
        balls.push({ x: paddle.x+paddle.w/2, y: paddle.y-10, dx: -4, dy: -4, r: 8, trail: [], speedScale: slowActive ? SLOW_FACTOR : 1 });
        if (slowActive) { const b=balls[balls.length-1]; b.dx*=SLOW_FACTOR; b.dy*=SLOW_FACTOR; }
      }
      if (buff.type==="slowBall") {
        applySlowBall(6000);
      }
      if (buff.type==="superPenetrate") {
        buffStates.superPenetrate = true;
        setTimeout(()=>{ buffStates.superPenetrate=false; }, 5000);
      }

      buffs.splice(i,1);
    }
  }

  // 更新炮弹（穿透）
  for (let i = bullets.length - 1; i >= 0; i--) {
    const blt = bullets[i];
    blt.y += blt.dy;
    for (let j = bricks.length - 1; j >= 0; j--) {
      const b = bricks[j];
      if (blt.x > b.x && blt.x < b.x + b.w && blt.y > b.y && blt.y < b.y + b.h) {
        bricks.splice(j,1);
        score += 10; updateHighScore();
      }
    }
    if (blt.y < -10) bullets.splice(i,1);
  }

  // 过关
  if (bricks.length===0) {
    level++;
    try { levelUpSound.play(); } catch(e){}
    initBricks();
    balls = [{ x: canvas.width/2, y: canvas.height-50, dx: 4, dy: -4, r: 8, trail: [], speedScale: slowActive ? SLOW_FACTOR : 1 }];
    if (slowActive) { balls[0].dx*=SLOW_FACTOR; balls[0].dy*=SLOW_FACTOR; }
    waitingLaunch=true;
    paddle.w=100;
    chargeAmmo = 0;
    lastChargeTime = performance.now();
  }
}

// ========= 主循环 =========
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPaddle();
  for (let ball of balls) drawBall(ball);
  drawBricks();
  drawBuffs();
  drawBullets();
  drawHUD();
  update();
  requestAnimationFrame(draw);
}

// ========= 控制：键盘 =========
window.addEventListener("keydown", e=>{
  if (e.key==="ArrowRight") rightPressed=true;
  if (e.key==="ArrowLeft") leftPressed=true;
  if (e.key===" " || e.code === "Space") spaceRequested = true;
});
window.addEventListener("keyup", e=>{
  if (e.key==="ArrowRight") rightPressed=false;
  if (e.key==="ArrowLeft") leftPressed=false;
});

// ========= 控制：触摸拖拽 + 轻点发射 =========
let touchStartX = null, touchStartY = null, touchStartTime = 0, lastTouchX = null;
canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  touchStartX = lastTouchX = t.clientX;
  touchStartY = t.clientY;
  touchStartTime = performance.now();
}, {passive:false});

canvas.addEventListener("touchmove", e => {
  e.preventDefault(); // 阻止滚动
  const t = e.touches[0];
  const dx = t.clientX - lastTouchX;
  paddle.x += dx;
  if (paddle.x < 0) paddle.x = 0;
  if (paddle.x + paddle.w > canvas.width) paddle.x = canvas.width - paddle.w;
  lastTouchX = t.clientX;
}, {passive:false});

canvas.addEventListener("touchend", e => {
  const dt = performance.now() - touchStartTime;
  const moved = Math.hypot((lastTouchX ?? touchStartX) - touchStartX, (touchStartY - touchStartY));
  // 轻点（短时且几乎不移动）→ 发射/开火
  if (dt < 250 && moved < 10) {
    spaceRequested = true;
  }
  touchStartX = touchStartY = lastTouchX = null;
}, {passive:false});

// ========= 控制：鼠标拖拽 + 点击发射（桌面） =========
let mouseDown = false, lastMouseX = 0;
canvas.addEventListener("mousedown", e => {
  mouseDown = true;
  lastMouseX = e.clientX;
});
window.addEventListener("mousemove", e => {
  if (!mouseDown) return;
  const dx = e.clientX - lastMouseX;
  paddle.x += dx;
  if (paddle.x < 0) paddle.x = 0;
  if (paddle.x + paddle.w > canvas.width) paddle.x = canvas.width - paddle.w;
  lastMouseX = e.clientX;
});
window.addEventListener("mouseup", e => {
  if (!mouseDown) return;
  mouseDown = false;
  // 轻点视为发射（鼠标按下很短、没有明显移动的情况此逻辑也适用）
  if (Math.abs(e.clientX - lastMouseX) < 2) {
    spaceRequested = true;
  }
});

// ========= 初始化 =========
function initGame() {
  resizeCanvas();
  paddle.x = canvas.width/2 - 50;
  paddle.y = canvas.height - 20;
  paddle.w = 100; paddle.h = 10;

  balls = [{ x: canvas.width/2, y: canvas.height-50, dx: 4, dy: -4, r: 8, trail: [], speedScale: 1 }];
  waitingLaunch = true;
  bricks = [];
  buffs = [];
  bullets = [];
  score = 0;
  lives = 3;
  level = 1;
  rightPressed = leftPressed = false;
  spaceRequested = false;

  lastBuffSpawnTime = performance.now();
  forceNextDropSplit = false;
  chargeAmmo = 0;
  lastChargeTime = 0;

  initBricks();
  requestAnimationFrame(draw);
}

initGame();
</script>
</body>
</html>

